package main

import (
	"fmt"
)

/*
 *  背景
 * 在某些场景下，我们需要同时从多个通道接收数据，通道在接收数据时，如果没有数据可以被接收，那么goroutine将会发送阻塞。次数我们需要写一个死循环接收渠道的值
 *
 * go 语言内置了select关键字，使用它可以同时响应多个通道的操作
 * select 的使用方式类是switch语句，每个case分支会对应一个通道的通信（接收或发送）过程。select会一直等待，知道其中某一个case的通信操作完成时，就回执行该case分支对应的语句
 */

/*
 * select 有以下特点
 * 可以处理一个或多个channel 的发送/接收操作
 * 如果多个case同时满足，select会随机选择一个执行
 * 对于没有case 的select会一直阻塞，可用于阻塞main函数，防止退出
 */

/*
 * 多返回模式
 * 当向通道中发送完数据时，我们可以通过close函数来关闭通道。当一个通道被关闭后，再往该通道发送值会引发panic，
 * 从该通道取值的操作会先取完通道中的值。通道内的值被接收完后再对通道执行接收操作得到的值会一直都是对应元素类型的零值。那我们如何判断一个通道是否被关闭了呢？
 * 对一个通道执行接收操作时支持使用如下多返回值模式。
 *
 * value, ok := <- ch
 * value：从通道中取出的值，如果通道被关闭则返回对应类型的零值。
 * ok：通道ch关闭时返回 false，否则返回 true。
 */

func main() {

	//分析，因为通道是一个缓存的长度，当 i == 1 的时候，case1 是不满足条件的，因为通道里还没有数据，所以走到了case2 一次循环结束
	//当 i == 2 时，case2因为通道里的位置满了，所以case2不满足条件，case1 中发现通道中有一个数据需要读出来，所以case1 满足条件，打印出 1 第二次循环结束
	//所以1,3,5,7,9循环的时候是满足输出条件的
	ch := make(chan int, 1)
	for i := 1; i <= 10; i++ {
		select {
		case x := <-ch:
			fmt.Println(x) // 1、3、5、7、9
		case ch <- i:
		}
	}

}
